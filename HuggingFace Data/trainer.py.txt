
The Trainer class, to easily train a ðŸ¤— Transformers from scratch or finetune it on a new task.


    Trainer is a simple but feature-complete training and eval loop for PyTorch, optimized for ðŸ¤— Transformers.

    Args:
        model ([`PreTrainedModel`] or `torch.nn.Module`, *optional*):
            The model to train, evaluate or use for predictions. If not provided, a `model_init` must be passed.

            <Tip>

            [`Trainer`] is optimized to work with the [`PreTrainedModel`] provided by the library. You can still use
            your own models defined as `torch.nn.Module` as long as they work the same way as the ðŸ¤— Transformers
            models.

            </Tip>

        args ([`TrainingArguments`], *optional*):
            The arguments to tweak for training. Will default to a basic instance of [`TrainingArguments`] with the
            `output_dir` set to a directory named *tmp_trainer* in the current directory if not provided.
        data_collator (`DataCollator`, *optional*):
            The function to use to form a batch from a list of elements of `train_dataset` or `eval_dataset`. Will
            default to [`default_data_collator`] if no `processing_class` is provided, an instance of
            [`DataCollatorWithPadding`] otherwise if the processing_class is a feature extractor or tokenizer.
        train_dataset (Union[`torch.utils.data.Dataset`, `torch.utils.data.IterableDataset`, `datasets.Dataset`], *optional*):
            The dataset to use for training. If it is a [`~datasets.Dataset`], columns not accepted by the
            `model.forward()` method are automatically removed.

            Note that if it's a `torch.utils.data.IterableDataset` with some randomization and you are training in a
            distributed fashion, your iterable dataset should either use a internal attribute `generator` that is a
            `torch.Generator` for the randomization that must be identical on all processes (and the Trainer will
            manually set the seed of this `generator` at each epoch) or have a `set_epoch()` method that internally
            sets the seed of the RNGs used.
        eval_dataset (Union[`torch.utils.data.Dataset`, Dict[str, `torch.utils.data.Dataset`, `datasets.Dataset`]), *optional*):
             The dataset to use for evaluation. If it is a [`~datasets.Dataset`], columns not accepted by the
             `model.forward()` method are automatically removed. If it is a dictionary, it will evaluate on each
             dataset prepending the dictionary key to the metric name.
        processing_class (`PreTrainedTokenizerBase` or `BaseImageProcessor` or `FeatureExtractionMixin` or `ProcessorMixin`, *optional*):
            Processing class used to process the data. If provided, will be used to automatically process the inputs
            for the model, and it will be saved along the model to make it easier to rerun an interrupted training or
            reuse the fine-tuned model.
            This supercedes the `tokenizer` argument, which is now deprecated.
        model_init (`Callable[[], PreTrainedModel]`, *optional*):
            A function that instantiates the model to be used. If provided, each call to [`~Trainer.train`] will start
            from a new instance of the model as given by this function.

            The function may have zero argument, or a single one containing the optuna/Ray Tune/SigOpt trial object, to
            be able to choose different architectures according to hyper parameters (such as layer count, sizes of
            inner layers, dropout probabilities etc).
        compute_loss_func (`Callable`, *optional*):
            A function that accepts the raw model outputs, labels, and the number of items in the entire accumulated
            batch (batch_size * gradient_accumulation_steps) and returns the loss. For example, here is one using
            the loss function from `transformers`
        compute_metrics (`Callable[[EvalPrediction], Dict]`, *optional*):
            The function that will be used to compute metrics at evaluation. Must take a [`EvalPrediction`] and return
            a dictionary string to metric values. *Note* When passing TrainingArgs with `batch_eval_metrics` set to
            `True`, your compute_metrics function must take a boolean `compute_result` argument. This will be triggered
            after the last eval batch to signal that the function needs to calculate and return the global summary
            statistics rather than accumulating the batch-level statistics
        callbacks (List of [`TrainerCallback`], *optional*):
            A list of callbacks to customize the training loop. Will add those to the list of default callbacks
            detailed in [here](callback).

            If you want to remove one of the default callbacks used, use the [`Trainer.remove_callback`] method.
        optimizers (`Tuple[torch.optim.Optimizer, torch.optim.lr_scheduler.LambdaLR]`, *optional*, defaults to `(None, None)`):
            A tuple containing the optimizer and the scheduler to use. Will default to an instance of [`AdamW`] on your
            model and a scheduler given by [`get_linear_schedule_with_warmup`] controlled by `args`.
        optimizer_cls_and_kwargs (`Tuple[Type[torch.optim.Optimizer], Dict[str, Any]]`, *optional*):
            A tuple containing the optimizer class and keyword arguments to use.
            Overrides `optim` and `optim_args` in `args`. Incompatible with the `optimizers` argument.

            Unlike `optimizers`, this argument avoids the need to place model parameters on the correct devices before initializing the Trainer.
        preprocess_logits_for_metrics (`Callable[[torch.Tensor, torch.Tensor], torch.Tensor]`, *optional*):
            A function that preprocess the logits right before caching them at each evaluation step. Must take two
            tensors, the logits and the labels, and return the logits once processed as desired. The modifications made
            by this function will be reflected in the predictions received by `compute_metrics`.

            Note that the labels (second parameter) will be `None` if the dataset does not have them.

    Important attributes:

        - **model** -- Always points to the core model. If using a transformers model, it will be a [`PreTrainedModel`]
          subclass.
        - **model_wrapped** -- Always points to the most external model in case one or more other modules wrap the
          original model. This is the model that should be used for the forward pass. For example, under `DeepSpeed`,
          the inner model is wrapped in `DeepSpeed` and then again in `torch.nn.DistributedDataParallel`. If the inner
          model hasn't been wrapped, then `self.model_wrapped` is the same as `self.model`.
        - **is_model_parallel** -- Whether or not a model has been switched to a model parallel mode (different from
          data parallelism, this means some of the model layers are split on different GPUs).
        - **place_model_on_device** -- Whether or not to automatically place the model on the device - it will be set
          to `False` if model parallel or deepspeed is used, or if the default
          `TrainingArguments.place_model_on_device` is overridden to return `False` .
        - **is_in_train** -- Whether or not a model is currently running `train` (e.g. when `evaluate` is called while
          in `train`)

    

        Activates the neftune as presented in this code: https://github.com/neelsjain/NEFTune and paper:
        https://arxiv.org/abs/2310.05914
        

        Deactivates the neftune method. Make sure to call `_activate_neftune` first.
        

        Add a callback to the current list of [`~transformers.TrainerCallback`].

        Args:
           callback (`type` or [`~transformers.TrainerCallback]`):
               A [`~transformers.TrainerCallback`] class or an instance of a [`~transformers.TrainerCallback`]. In the
               first case, will instantiate a member of that class.
        

        Remove a callback from the current list of [`~transformers.TrainerCallback`] and returns it.

        If the callback is not found, returns `None` (and no error is raised).

        Args:
           callback (`type` or [`~transformers.TrainerCallback]`):
               A [`~transformers.TrainerCallback`] class or an instance of a [`~transformers.TrainerCallback`]. In the
               first case, will pop the first member of that class found in the list of callbacks.

        Returns:
            [`~transformers.TrainerCallback`]: The callback removed, if found.
        

        Remove a callback from the current list of [`~transformers.TrainerCallback`].

        Args:
           callback (`type` or [`~transformers.TrainerCallback]`):
               A [`~transformers.TrainerCallback`] class or an instance of a [`~transformers.TrainerCallback`]. In the
               first case, will remove the first member of that class found in the list of callbacks.
        
Wrap the data collator in a callable removing unused columns.

        Returns the training [`~torch.utils.data.DataLoader`].

        Will use no sampler if `train_dataset` does not implement `__len__`, a random sampler (adapted to distributed
        training if necessary) otherwise.

        Subclass and override this method if you want to inject some custom behavior.
        

        Returns the evaluation [`~torch.utils.data.DataLoader`].

        Subclass and override this method if you want to inject some custom behavior.

        Args:
            eval_dataset (`str` or `torch.utils.data.Dataset`, *optional*):
                If a `str`, will use `self.eval_dataset[eval_dataset]` as the evaluation dataset. If a `Dataset`, will override `self.eval_dataset` and must implement `__len__`. If it is a [`~datasets.Dataset`], columns not accepted by the `model.forward()` method are automatically removed.
        

        Returns the test [`~torch.utils.data.DataLoader`].

        Subclass and override this method if you want to inject some custom behavior.

        Args:
            test_dataset (`torch.utils.data.Dataset`, *optional*):
                The test dataset to use. If it is a [`~datasets.Dataset`], columns not accepted by the
                `model.forward()` method are automatically removed. It must implement `__len__`.
        

        Setup the optimizer and the learning rate scheduler.

        We provide a reasonable default that works well. If you want to use something else, you can pass a tuple in the
        Trainer's init through `optimizers`, or subclass and override this method (or `create_optimizer` and/or
        `create_scheduler`) in a subclass.
        

        Get all parameter names that weight decay will be applied to

        Note that some models implement their own layernorm instead of calling nn.LayerNorm, weight decay could still
        apply to those modules since this function only filter out instance of nn.LayerNorm
        

        Setup the optimizer.

        We provide a reasonable default that works well. If you want to use something else, you can pass a tuple in the
        Trainer's init through `optimizers`, or subclass and override this method in a subclass.
        

        Get the number of trainable parameters.
        

        Returns the learning rate of each parameter from self.optimizer.
        

        Returns optimizer group for a parameter if given, else returns all optimizer groups for params.

        Args:
            param (`str` or `torch.nn.parameter.Parameter`, *optional*):
                The parameter for which optimizer group needs to be returned.
        

        Returns the optimizer class and optimizer parameters based on the training arguments.

        Args:
            args (`transformers.training_args.TrainingArguments`):
                The training arguments for the training session.

        

        Setup the scheduler. The optimizer of the trainer must have been set up either before this method is called or
        passed as an argument.

        Args:
            num_training_steps (int): The number of training steps to do.
        

        Helper to get number of samples in a [`~torch.utils.data.DataLoader`] by accessing its dataset. When
        dataloader.dataset does not exist or has no length, estimates as best it can
        

        Helper to get number of tokens in a [`~torch.utils.data.DataLoader`] by enumerating dataloader.
        
HP search setup code

        Main training entry point.

        Args:
            resume_from_checkpoint (`str` or `bool`, *optional*):
                If a `str`, local path to a saved checkpoint as saved by a previous instance of [`Trainer`]. If a
                `bool` and equals `True`, load the last checkpoint in *args.output_dir* as saved by a previous instance
                of [`Trainer`]. If present, training will resume from the model/optimizer/scheduler states loaded here.
            trial (`optuna.Trial` or `Dict[str, Any]`, *optional*):
                The trial run or the hyperparameter dictionary for hyperparameter search.
            ignore_keys_for_eval (`List[str]`, *optional*)
                A list of keys in the output of your model (if it is a dictionary) that should be ignored when
                gathering predictions for evaluation during the training.
            kwargs (`Dict[str, Any]`, *optional*):
                Additional keyword arguments used to hide deprecated arguments
        

        Determine if the model should be saved based on the evaluation metrics.
        If args.metric_for_best_model is not set, the loss is used.

        Returns:
            bool: True if a new best metric was found, else False
        
If optimizer and scheduler states exist, load them.
If callback states exist and were passed in, restore their states if enabled

        Launch an hyperparameter search using `optuna` or `Ray Tune` or `SigOpt`. The optimized quantity is determined
        by `compute_objective`, which defaults to a function returning the evaluation loss when no metric is provided,
        the sum of all metrics otherwise.

        <Tip warning={true}>

        To use this method, you need to have provided a `model_init` when initializing your [`Trainer`]: we need to
        reinitialize the model at each new run. This is incompatible with the `optimizers` argument, so you need to
        subclass [`Trainer`] and override the method [`~Trainer.create_optimizer_and_scheduler`] for custom
        optimizer/scheduler.

        </Tip>

        Args:
            hp_space (`Callable[["optuna.Trial"], Dict[str, float]]`, *optional*):
                A function that defines the hyperparameter search space. Will default to
                [`~trainer_utils.default_hp_space_optuna`] or [`~trainer_utils.default_hp_space_ray`] or
                [`~trainer_utils.default_hp_space_sigopt`] depending on your backend.
            compute_objective (`Callable[[Dict[str, float]], float]`, *optional*):
                A function computing the objective to minimize or maximize from the metrics returned by the `evaluate`
                method. Will default to [`~trainer_utils.default_compute_objective`].
            n_trials (`int`, *optional*, defaults to 100):
                The number of trial runs to test.
            direction (`str` or `List[str]`, *optional*, defaults to `"minimize"`):
                If it's single objective optimization, direction is `str`, can be `"minimize"` or `"maximize"`, you
                should pick `"minimize"` when optimizing the validation loss, `"maximize"` when optimizing one or
                several metrics. If it's multi objectives optimization, direction is `List[str]`, can be List of
                `"minimize"` and `"maximize"`, you should pick `"minimize"` when optimizing the validation loss,
                `"maximize"` when optimizing one or several metrics.
            backend (`str` or [`~training_utils.HPSearchBackend`], *optional*):
                The backend to use for hyperparameter search. Will default to optuna or Ray Tune or SigOpt, depending
                on which one is installed. If all are installed, will default to optuna.
            hp_name (`Callable[["optuna.Trial"], str]]`, *optional*):
                A function that defines the trial/run name. Will default to None.
            kwargs (`Dict[str, Any]`, *optional*):
                Additional keyword arguments passed along to `optuna.create_study` or `ray.tune.run`. For more
                information see:

                - the documentation of
                  [optuna.create_study](https://optuna.readthedocs.io/en/stable/reference/generated/optuna.study.create_study.html)
                - the documentation of [tune.run](https://docs.ray.io/en/latest/tune/api_docs/execution.html#tune-run)
                - the documentation of [sigopt](https://app.sigopt.com/docs/endpoints/experiments/create)

        Returns:
            [`trainer_utils.BestRun` or `List[trainer_utils.BestRun]`]: All the information about the best run or best
            runs for multi-objective optimization. Experiment summary can be found in `run_summary` attribute for Ray
            backend.
        

        Log `logs` on the various objects watching training.

        Subclass and override this method to inject custom behavior.

        Args:
            logs (`Dict[str, float]`):
                The values to log.
        

        Prepares one `data` before feeding it to the model, be it a tensor or a nested list/dictionary of tensors.
        

        Prepare `inputs` before feeding them to the model, converting them to tensors if they are not already and
        handling potential state.
        

        A helper wrapper to group together context managers.
        

        A helper wrapper that creates an appropriate context manager for `autocast` while feeding it the desired
        arguments, depending on the situation.
        

        Perform a training step on a batch of inputs.

        Subclass and override to inject custom behavior.

        Args:
            model (`nn.Module`):
                The model to train.
            inputs (`Dict[str, Union[torch.Tensor, Any]]`):
                The inputs and targets of the model.

                The dictionary will be unpacked before being fed to the model. Most models expect the targets under the
                argument `labels`. Check your model's documentation for all accepted arguments.

        Return:
            `torch.Tensor`: The tensor with training loss on this batch.
        

        How the loss is computed by Trainer. By default, all models return the loss in the first element.

        Subclass and override for custom behavior.
        

        Whether or not this process is the local (e.g., on one machine if training in a distributed fashion on several
        machines) main process.
        

        Whether or not this process is the global main process (when training in a distributed fashion on several
        machines, this is only going to be `True` for one process).
        

        Will save the model, so you can reload it using `from_pretrained()`.

        Will only save from the main process.
        

        Run evaluation and returns metrics.

        The calling script will be responsible for providing a method to compute metrics, as they are task-dependent
        (pass it to the init `compute_metrics` argument).

        You can also subclass and override this method to inject custom behavior.

        Args:
            eval_dataset (Union[`Dataset`, Dict[str, `Dataset`]), *optional*):
                Pass a dataset if you wish to override `self.eval_dataset`. If it is a [`~datasets.Dataset`], columns
                not accepted by the `model.forward()` method are automatically removed. If it is a dictionary, it will
                evaluate on each dataset, prepending the dictionary key to the metric name. Datasets must implement the
                `__len__` method.

                <Tip>

                If you pass a dictionary with names of datasets as keys and datasets as values, evaluate will run
                separate evaluations on each dataset. This can be useful to monitor how training affects other
                datasets or simply to get a more fine-grained evaluation.
                When used with `load_best_model_at_end`, make sure `metric_for_best_model` references exactly one
                of the datasets. If you, for example, pass in `{"data1": data1, "data2": data2}` for two datasets
                `data1` and `data2`, you could specify `metric_for_best_model="eval_data1_loss"` for using the
                loss on `data1` and `metric_for_best_model="eval_data2_loss"` for the loss on `data2`.

                </Tip>

            ignore_keys (`List[str]`, *optional*):
                A list of keys in the output of your model (if it is a dictionary) that should be ignored when
                gathering predictions.
            metric_key_prefix (`str`, *optional*, defaults to `"eval"`):
                An optional prefix to be used as the metrics key prefix. For example the metrics "bleu" will be named
                "eval_bleu" if the prefix is "eval" (default)

        Returns:
            A dictionary containing the evaluation loss and the potential metrics computed from the predictions. The
            dictionary also contains the epoch number which comes from the training state.
        

        Run prediction and returns predictions and potential metrics.

        Depending on the dataset and your use case, your test dataset may contain labels. In that case, this method
        will also return metrics, like in `evaluate()`.

        Args:
            test_dataset (`Dataset`):
                Dataset to run the predictions on. If it is an `datasets.Dataset`, columns not accepted by the
                `model.forward()` method are automatically removed. Has to implement the method `__len__`
            ignore_keys (`List[str]`, *optional*):
                A list of keys in the output of your model (if it is a dictionary) that should be ignored when
                gathering predictions.
            metric_key_prefix (`str`, *optional*, defaults to `"test"`):
                An optional prefix to be used as the metrics key prefix. For example the metrics "bleu" will be named
                "test_bleu" if the prefix is "test" (default)

        <Tip>

        If your predictions or labels have different sequence length (for instance because you're doing dynamic padding
        in a token classification task) the predictions will be padded (on the right) to allow for concatenation into
        one array. The padding index is -100.

        </Tip>

        Returns: *NamedTuple* A namedtuple with the following keys:

            - predictions (`np.ndarray`): The predictions on `test_dataset`.
            - label_ids (`np.ndarray`, *optional*): The labels (if the dataset contained some).
            - metrics (`Dict[str, float]`, *optional*): The potential dictionary of metrics (if the dataset contained
              labels).
        

        Prediction/evaluation loop, shared by `Trainer.evaluate()` and `Trainer.predict()`.

        Works both with or without labels.
        

        Gather value of `tensors` (tensor or list/tuple of nested tensors) and convert them to numpy before
        concatenating them to `gathered`
        

        Perform an evaluation step on `model` using `inputs`.

        Subclass and override to inject custom behavior.

        Args:
            model (`nn.Module`):
                The model to evaluate.
            inputs (`Dict[str, Union[torch.Tensor, Any]]`):
                The inputs and targets of the model.

                The dictionary will be unpacked before being fed to the model. Most models expect the targets under the
                argument `labels`. Check your model's documentation for all accepted arguments.
            prediction_loss_only (`bool`):
                Whether or not to return the loss only.
            ignore_keys (`List[str]`, *optional*):
                A list of keys in the output of your model (if it is a dictionary) that should be ignored when
                gathering predictions.

        Return:
            Tuple[Optional[torch.Tensor], Optional[torch.Tensor], Optional[torch.Tensor]]: A tuple with the loss,
            logits and labels (each being optional).
        

        For models that inherit from [`PreTrainedModel`], uses that method to compute the number of floating point
        operations for every backward + forward pass. If using another model, either implement such a method in the
        model or subclass and override this method.

        Args:
            inputs (`Dict[str, Union[torch.Tensor, Any]]`):
                The inputs and targets of the model.

        Returns:
            `int`: The number of floating-point operations.
        

        Initializes a git repo in `self.args.hub_model_id`.
        

        Creates a draft of a model card using the information available to the `Trainer`.

        Args:
            language (`str`, *optional*):
                The language of the model (if applicable)
            license (`str`, *optional*):
                The license of the model. Will default to the license of the pretrained model used, if the original
                model given to the `Trainer` comes from a repo on the Hub.
            tags (`str` or `List[str]`, *optional*):
                Some tags to be included in the metadata of the model card.
            model_name (`str`, *optional*):
                The name of the model.
            finetuned_from (`str`, *optional*):
                The name of the model used to fine-tune this one (if applicable). Will default to the name of the repo
                of the original model given to the `Trainer` (if it comes from the Hub).
            tasks (`str` or `List[str]`, *optional*):
                One or several task identifiers, to be included in the metadata of the model card.
            dataset_tags (`str` or `List[str]`, *optional*):
                One or several dataset tags, to be included in the metadata of the model card.
            dataset (`str` or `List[str]`, *optional*):
                One or several dataset identifiers, to be included in the metadata of the model card.
            dataset_args (`str` or `List[str]`, *optional*):
               One or several dataset arguments, to be included in the metadata of the model card.
        

        Upload `self.model` and `self.processing_class` to the ðŸ¤— model hub on the repo `self.args.hub_model_id`.

        Parameters:
            commit_message (`str`, *optional*, defaults to `"End of training"`):
                Message to commit while pushing.
            blocking (`bool`, *optional*, defaults to `True`):
                Whether the function should return only when the `git push` has finished.
            token (`str`, *optional*, defaults to `None`):
                Token with write permission to overwrite Trainer's original args.
            revision (`str`, *optional*):
                The git revision to commit from. Defaults to the head of the "main" branch.
            kwargs (`Dict[str, Any]`, *optional*):
                Additional keyword arguments passed along to [`~Trainer.create_model_card`].

        Returns:
            The URL of the repository where the model was pushed if `blocking=False`, or a `Future` object tracking the
            progress of the commit if `blocking=True`.
        

        Prediction/evaluation loop, shared by `Trainer.evaluate()` and `Trainer.predict()`.

        Works both with or without labels.
        

        Gather value of `tensors` (tensor or list/tuple of nested tensors) and convert them to numpy before
        concatenating them to `gathered`
        
Add SageMaker Checkpointing patterns to .gitignore file.

        Sets values in the deepspeed plugin based on the Trainer args
        
# coding=utf-8
# Copyright 2020-present the HuggingFace Inc. team.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Integrations must be imported before ML frameworks:
# isort: off
# isort: on
# Here we also check if the model is an instance of `PeftMixedModel` introduced in peft>=0.7.0: https://github.com/huggingface/transformers/pull/28321
# TODO: @AjayP13, @younesbelkada replace this check with version check at the next `accelerate` release
# Name of the files used for checkpointing
# Those are used as methods of the Trainer in examples.
# Seed must be set before instantiating the model when using model
# memory metrics - must set up as early as possible
# set the correct log level depending on the node
# force device and distributed setup init explicitly
# warn users
# Patch the model with liger kernels. Use the default kernel configurations.
# Filter out quantized + compiled models
# At this stage the model is already loaded
# one place to sort out whether to place the model on device or not
# postpone switching model to cuda when:
# 1. MP - since we are trying to fit a much bigger than 1 gpu model
# 2. fp16-enabled DeepSpeed loads the model in half the size and it doesn't need .to() anyway,
#    and we only use deepspeed for training at the moment
# 3. full bf16 or fp16 eval - since the model needs to be cast to the right dtype first
# 4. FSDP - same as MP
# Bnb Quantized models doesn't support `.to` operation.
# Force n_gpu to 1 to avoid DataParallel as MP will manage the GPUs
# later use `self.model is self.model_wrapped` to check if it's wrapped or not
# Just in case the model was wrapped outside of the `Trainer`
# Will be set to True by `self._setup_loggers()` on first call to `self.log()`.
# Create distant repo and output directory if needed
# Mixed precision setup
# Mixed precision setup for SageMaker Model Parallel
# BF16 + model parallelism in SageMaker: currently not supported, raise an error
# When there's mismatch between SMP config and trainer argument, use SMP config as truth
# smp < 1.10 does not support fp16 in trainer.
# deepspeed and SageMaker Model Parallel manage their own half precision
# Label smoothing
# Internal variable to count flos in each process, will be accumulated in `self.state.total_flos` then
# returned to 0 every time flos need to be logged
# Internal variables to help with automatic batch size reduction
# very last
# torch.compile
# Prepare the SPMD mesh that is going to be used by the data loader and the FSDPv2 wrapper.
# Tensor axis is just a placeholder where it will not be used in FSDPv2.
# Moving a model to an XLA device disconnects the tied weights, so we have to retie them.
# Inspect model forward signature to keep only the arguments it accepts.
# PeftMixedModel do not provide a `get_base_model` method
# Labels may be named label or label_ids, the default data collator handles that.
# Build the sampler.
# Build the sampler.
# Deprecated code
# If we have persistent workers, don't do a fork bomb especially as eval datasets
# don't change during training
# accelerator.free_memory() will destroy the references, so
# we need to store the non-prepared version
# We use the same batch_size as for eval.
# If smp >= 1.10 and fp16 is enabled, we unwrap the optimizer
# Overwrite `params` in case it's created by `get_optimizer_cls_and_kwargs`
# e.g. for GaLore optimizer.
# Overwrite `model` in case it's created by `get_optimizer_cls_and_kwargs`
# e.g. for LOMO optimizer.
# For layer-wise dummy optimizers we overwrite optimizer_grouped_parameters with `optimizer_dict`
# to avoid arguments conflicts.
# parse args.optim_args
# Above we pass all `adam_kwargs` to the optimizer, here
# we only pass `optim_args` which can be passed by the user.
# TODO Change dtypes back to M=FP32, Var = BF16, Kahan = False once they can be cast together in torchdistx.
# Warn in case we match but it's not a linear layer
# The default args are from the official repository: https://github.com/jiaweizzhao/GaLore
# For layer-wise optimizers, the optimization step is done through post accumulation
# gradient hooks. The trick is to first attach these hooks to the model parameters then
# create a dummy optimizer that will perform no-ops in the Trainer.
# See the original implementation or the nice implementation from @hiyouga
# here: https://github.com/hiyouga/LLaMA-Factory/commit/8664262cde3919e10eaecbd66e8c5d356856362e#diff-ebe08ab14496dfb9e06075f0fdd36799ef6d1535cc4dd4715b74c4e3e06fe3ba
# Special case for IterableDatasetShard, we need to dig deeper
# no dataset or length, estimate by length of dataloader
# Casting value to the proper type
# Rebuild the deepspeed config to reflect the updated training parameters
# From 1.0 on, we need to fully wipe the DS plugin when doing sweeps.
# Simply calling `_reset_state` is enough and doesn't need a version pin.
# Update the `TrainerControl` state to where we are currently
# remove mixed precision hooks from the model
# conv_bn_folding is disabled as it fails in symbolic tracing, resulting in ipex warnings
# train bs is special as we need to account for multi-GPU
# Wrapping the base model twice in a DistributedModel will raise an error.
# train/eval could be run multiple-times - if already wrapped, don't re-wrap it again
# Mixed precision training with apex (torch < 1.6)
# Multi-gpu training (should be after apex fp16 initialization) / 8bit models does not support DDP
# Note: in torch.distributed mode, there's no point in wrapping the model
# inside a DistributedDataParallel as we'll be under `no_grad` anyways.
# Distributed training (should be after apex fp16 initialization)
# Distributed training using PyTorch FSDP
# Transformer layer class to wrap
# Apply gradient checkpointing to auto-wrapped sub-modules if specified
# Wrap the base model with an outer FSDP wrapper
# Patch `xm.optimizer_step` should not reduce gradients in this case,
# as FSDP does not need gradient reduction over sharded parameters.
# find_unused_parameters breaks checkpointing as per
# https://github.com/huggingface/transformers/pull/4659#issuecomment-643356021
# memory metrics - must set up as early as possible
# Attach NEFTune hooks if necessary
# do_train is not a reliable argument, as it might not be set and .train() still called, so
# the following is a workaround:
# This might change the seed so needs to run first.
# Model re-init
# Seed must be set before instantiating the model when using model_init.
# Reinitializes optimizer and scheduler
# Load potential model checkpoint
# In case of repeating the find_executable_batch_size, set `self._train_batch_size` properly
# If model was re-initialized, put it on the right device and update self.model_wrapped
# Disable progress bars when uploading models during checkpoints to avoid polluting stdout
# Check for DeepSpeed *after* the intial pass and modify the config
# Temporarily unset `self.args.train_batch_size`
# Data loader and number of training steps
# Setting up training control variables:
# number of training epochs: num_train_epochs
# number of training steps per epoch: num_update_steps_per_epoch
# total number of training steps to execute: max_steps
# May be slightly incorrect if the last batch in the training dataloader has a smaller size but it's
# the best we can do.
# Rely on max_steps when dataloader does not have a working size
# Setting a very large number of epochs so we go as many times as necessary over the iterator.
# nn.DataParallel(model) replicates the model, creating new variables and module
# references registered here no longer work on other gpus, breaking the module
# noqa
# We need to reset the scheduler, as its parameters may be different on subsequent calls
# Compute absolute values for logging, eval, and save if given as ratio
# Activate gradient checkpointing if needed
# as the model is wrapped, don't use `accelerator.prepare`
# this is for unhandled cases such as
# FSDP-XLA, SageMaker MP/DP, DataParallel, IPEX
# configure fsdp plugin for qlora if any
# prepare using `accelerator` prepare
# to handle cases wherein we pass "DummyScheduler" such as when it is specified in DeepSpeed config.
# In this case we are in DDP + LOMO, which should be supported
# for the rest of this function `model` is the outside model, whether it was wrapped or not
# backward compatibility
# ckpt loading
# Check if saved optimizer or scheduler states exist
# important: at this point:
# self.model         is the Transformers Model
# self.model_wrapped is DDP(Transformers Model), Deepspeed(Transformers Model),
# FSDP(Transformers Model), Dynamo Optimized Module(Transformers Model) etc.
# Train!
# Check if continuing training from a checkpoint
# Update the references
# use self._trial because the SigOpt/Optuna hpo only call `_hp_search_setup(trial)` instead of passing trial
# parameter to Train when using DDP.
# This should be the same if the state has been saved but in case the training arguments changed, it's safer
# to set this after the load.
# tr_loss is a tensor to avoid synchronization of TPUs through .item()
# _total_loss_scalar is updated everytime .item() has to be called on tr_loss and stores the sum of all losses
# Reset the past mems state at the beginning of each epoch if necessary.
# We chunkify the epoch iterator into gradient accumulation steps `n` batches
# Since we perform prefetching, we need to manually set sync_gradients
# Skip past any already trained steps if resuming training
# if loss is nan or inf simply add the average of previous logged losses
# Since we perform prefetching, we need to manually set sync_gradients to True
# Gradient clipping
# deepspeed does its own clipping
# Revert to normal clipping otherwise, handling Apex or full precision
# In some cases the grad norm may not return a float
# Delay optimizer scheduling until metrics are generated
# PyTorch/XLA relies on the data loader to insert the mark_step for
# each step. Since we are breaking the loop early, we need to manually
# insert the mark_step here.
# We also need to break out of the nested loop
# tpu-comment: Logging debug metrics for PyTorch/XLA (compile, execute times, ops, etc.)
# Clean the state at the end of training
# Wait for everyone to get here so we are sure the model has been saved by process 0.
# add remaining tr_loss
# Avoid ZeroDivisionError
# Delete the last checkpoint when save_total_limit=1 if it's different from the best checkpoint and process allowed to save.
# Wait for the checkpoint to be uploaded.
# After training we make sure to retrieve back the original forward pass method
# for the embedding layer by removing the forward post hook.
# this checks the FSDP state dict when `SHARDED_STATE_DICT` is used
# this checks the FSDP state dict when `FULL_STATE_DICT` is used
# if multiple adapters exist, they get saved in sub directories
# If the model is on the GPU, it still works!
# If the 'user_content.pt' file exists, load with the new smp api.
# Checkpoint must have been saved with the new smp api.
# If the 'user_content.pt' file does NOT exist, load with the old smp api.
# Checkpoint must have been saved with the old smp api.
# Required for smp to not auto-translate state_dict from hf to smp (is already smp).
# release memory
# We load the model state dict on the CPU to avoid an OOM error.
# workaround for FSDP bug https://github.com/pytorch/pytorch/issues/82963
# which takes *args instead of **kwargs
# release memory
# Load adapters following PR # 24096
# If train a model using PEFT & LoRA, assume that adapter have been saved properly.
# TODO: in the future support only specific min PEFT versions
# For BC for older PEFT versions
# We load the sharded checkpoint
# If the 'user_content.pt' file exists, load with the new smp api.
# Checkpoint must have been saved with the new smp api.
# If the 'user_content.pt' file does NOT exist, load with the old smp api.
# Checkpoint must have been saved with the old smp api.
# If train a model using PEFT & LoRA, assume that adapter have been saved properly.
# TODO: in the future support only specific min PEFT versions
# For BC for older PEFT versions
# Load_adapter has no return value present, modify it when appropriate.
# We load the model state dict on the CPU to avoid an OOM error.
# If the model is on the GPU, it still works!
# workaround for FSDP bug https://github.com/pytorch/pytorch/issues/82963
# which takes *args instead of **kwargs
# Run delayed LR scheduler now that metrics are populated
# all_gather + mean() to get average loss over all processes
# reset tr_loss to zero
# Load RNG states from `checkpoint`
# In all cases, including ddp/dp/deepspeed, self.model is always a reference to the model we
# want to save except FullyShardedDDP.
# assert unwrap_model(model) is self.model, "internal model should be a reference to self.model"
# Save model checkpoint
# Save optimizer and scheduler
# Save RNG state
# Save the Trainer state
# Update `ExportableState` callbacks and `TrainerControl` state to where we are currently
# Maybe delete some older checkpoints.
# Solely rely on numerical checkpoint id for rotation.
# mtime is not reliable especially on some fuse fs in cloud environments.
# Save RNG state in non-distributed training
# In non distributed, we save the global CUDA RNG state (will take care of DataParallel)
# A process can arrive here before the process 0 has a chance to save the model, in which case output_dir may
# not yet exist.
# under zero3 model file itself doesn't get saved since it's bogus! Unless deepspeed
# config `stage3_gather_16bit_weights_on_model_save` is True
# save fsdp specific ckpt for resuming from ckpt
# deepspeed.save_checkpoint above saves model/optim/sched
# Save SCHEDULER & SCALER
# deepspeed loads optimizer/lr_scheduler together with the model in deepspeed_init
# Load in optimizer and scheduler states
# On TPU we have to take some extra precautions to properly load the states on the right device.
# We only need `optimizer` when resuming from checkpoint
# Optimizer checkpoint was saved with smp >= 1.10
# Optimizer checkpoint was saved with smp < 1.10
# We use the CPU when training on one GPU to avoid OOM for GPU RAM when training big models.
# In distributed training however, we load directly on each GPU and risk the GPU OOM as it's more
# likely to get OOM on CPU (since we load num_gpu times the optimizer state
# Callback states are stored in stateful_callbacks
# We can load/restore from multiple callbacks of the same type.
# Specifically for restoring the `control` state
# We remove the existing callback and add it to the list of new callbacks
#tune-run)
# NLP models inputs are int/uint and those get adjusted to the right dtype of the
# embedding. Other models such as wav2vec2's inputs are already float and thus
# may need special handling to match the dtypes of the model
# For LOMO optimizers you need to explicitly use the learnign rate
# mean() to average on multi-gpu parallel training
# Average tokens across devices is orthogonal to gradient accumulation
# Save past state if it exists
# TODO: this needs to be fixed and made cleaner later.
# User-defined compute_loss function
# We don't use .loss here since the model may return tuples instead of ModelOutput.
# Special case for SageMaker ModelParallel since there process_index is dp_process_index, not the global
# process index.
# Calling the state_dict needs to be done on the wrapped model and on all processes.
# 'user_content.pt' indicates model state_dict saved with smp >= 1.10
# remove the dummy state_dict
# Push to the Hub when `save_model` is called by the user.
# Save a trained model and configuration using `save_pretrained()`.
# They can then be reloaded using `from_pretrained()`
# All ranks save sharded checkpoint
# Make sure all ranks have saved checkpoints
# Master save full checkpoint
# If we are executing this function, we are the process zero, so we don't check for that.
# Save a trained model and configuration using `save_pretrained()`.
# They can then be reloaded using `from_pretrained()`
# Good practice: save your training arguments together with the trained model
# Storing the number of floating-point operations that went into the model
# Make sure we don't delete the best model.
# Check if we should delete older checkpoint(s)
# If save_total_limit=1 with load_best_model_at_end=True, we could end up deleting the last checkpoint, which
# we don't do to allow resuming.
# handle multipe eval datasets
# memory metrics - must set up as early as possible
# No point gathering the predictions if there are no metrics, otherwise we defer to
# self.args.prediction_loss_only
# tpu-comment: Logging debug metrics for PyTorch/XLA (compile, execute times, ops, etc.)
# memory metrics - must set up as early as possible
# if eval is called w/o train, handle model prep here
# for the rest of this function `model` is the outside model, whether it was wrapped or not
# backward compatibility
# if full fp16 or bf16 eval is wanted and this ``evaluation`` or ``predict`` isn't called
# while ``train`` is running, cast it to the right dtype first and then put on device
# Do this before wrapping.
# Initialize containers
# Will be useful when we have an iterable dataset so don't know its length.
# Main evaluation loop
# Update the observed num examples
# For batch samplers, batch_size is not known by the dataloader in advance.
# Prediction step
# Update containers
# Pad labels here, preparing for preprocess_logits_for_metrics in next logits block.
# Gather all tensors and put them back on the CPU if we have done enough accumulation steps.
# After all calls to `.gather_function`, reset to `gather_for_metrics`:
# Clean the state at the end of the evaluation loop
# Gather all remaining tensors and put them back on the CPU
# Number of samples
# The instance check is weird and does not actually check for the type, but whether the dataset has the right
# methods. Therefore we need to make sure it also has the attribute.
# both len(dataloader.dataset) and len(dataloader) fail
# Metrics!
# To be JSON-serializable, we need to remove numpy types or zero-d tensors
# Prefix all keys with metric_key_prefix + '_'
# For CLIP-like models capable of returning loss values.
# If `return_loss` is not specified or being `None` in `inputs`, we check if the default value of `return_loss`
# is `True` in `model.forward`.
# labels may be popped when computing the loss (label smoothing for instance) so we grab them first.
# TODO: this needs to be fixed and made cleaner later.
# Only on process zero
# Append existing tags in `tags`
# Only push from one node.
# If we haven't finished the last push, we don't do this one unless args.hub_always_push=True.
# To avoid a new synchronization of all model weights, we just copy the file from the checkpoint folder
#  Add sharded checkpoints if we have an index
# Saving the processing class is fast and we don't know how many files it may have spawned, so we resave it to be sure.
# Same for the training arguments
# In case the user calls this method with args.push_to_hub = False
# Needs to be executed on all processes for TPU training, but will only save on the processed determined by
# self.args.should_save.
# Only push from one node.
# Add additional tags in the case the model has already some tags and users pass
# "tags" argument to `push_to_hub` so that trainer automatically handles internal tags
# from all models since Trainer does not call `model.push_to_hub`.
# If it is a string, convert it to a list
# Wait for the current upload to be finished.
#
# Deprecated code
#
# if eval is called w/o train, handle model prep here
# for the rest of this function `model` is the outside model, whether it was wrapped or not
# backward compatibility
# if full fp16 or bf16 eval is wanted and this ``evaluation`` or ``predict`` isn't called
# while ``train`` is running, cast it to the right dtype first and then put on device
# The actual number of eval_sample can be greater than num_examples in distributed settings (when we pass
# a batch size to the sampler)
# Gather all tensors and put them back on the CPU if we have done enough accumulation steps.
# Set back to None to begin a new accumulation
# Clean the state at the end of the evaluation loop
# Gather all remaining tensors and put them back on the CPU
# To be JSON-serializable, we need to remove numpy types or zero-d tensors
# Prefix all keys with metric_key_prefix + '_'
# Make sure we only do this on the main process
# Get current .gitignore content
# Add the patterns to .gitignore
# Write the .gitignore file if it has changed
# avoid race condition with git status
# check if num_steps is attempted to be passed in gradient_accumulation_kwargs
# raise because we do not know which setting is intended.
# take the gradient_accumulation_steps setting from TrainingArguments.
# this would have been updated above, no need for it anymore
# create accelerator object
# some Trainer classes need to use `gather` instead of `gather_for_metrics`, thus we store a flag
# deepspeed and accelerate flags covering both trainer args and accelerate launcher
# post accelerator creation setup
# `save_only_model` can't be used with DeepSpeed/FSDP along with `load_best_model_at_end`
# `auto_find_batch_size` isn't supported yet with DeepSpeed Zero-3
# For now we don't support object detection